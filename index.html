<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            position: relative; 
            overflow: hidden;
        }
        #scoreContainer {
            position: absolute;
            top: 10%;
            left: 15%; 
            color: white;
            font-size: 25px;
            font-family: Arial, sans-serif;
            background-color: rgba(255, 255, 255, 0.345);
            padding-left: 30px;
            padding-right: 30px;
            border-radius: 10px;
            width: auto; 
        }
        #gameContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 560px; /* Samma bredd som spelområdet */
            height: 620px; /* Samma höjd som spelområdet */
        }
        #gameArea {
            scale: 1.5; /* Skala upp spelområdet */
            display: grid;
            width: 560px;
            height: 620px;
            grid-template-columns: repeat(28, 20px);
            grid-template-rows: repeat(31, 20px);
            background-color: rgb(0, 0, 0);
            position: relative;
        }
        #pacman {
            width: 100%; 
            height: 100%;
            background-color: yellow;
            border-radius: 50%;
        }
        .dot {
            width: 20%; 
            height: 20%;
            background-color: rgb(255, 191, 191);
            border-radius: 50%;
            justify-self: center;
            align-self: center;
        }
        .wall {
            background-color: rgb(0, 0, 142);
            width: 20px;
            height: 20px;
        }
        #ghost {
            width: 15px;
            height: 15px; 
            background-color: red;
            border-radius: 50%; 
            transform: translate(15%, 15%);
            position: absolute;
        }
        #ghost2, #ghost3, #ghost4 {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            position: absolute;
            transform: translate(15%, 15%);
        }
    </style>
</head>
<body>
     <script src="pinkghost.js"></script>
    <div id="scoreContainer">
        <p>Poäng: <span id="score">0</span></p>
    </div>
    <div id="gameContainer">
        <div id="gameArea">
            <div id="pacman"></div>
        </div>
    </div>
    <script>
        const pacman = document.getElementById('pacman');
        const gameArea = document.getElementById('gameArea');
        const scoreElement = document.getElementById('score');
        let pacmanPosition = { x: 15, y: 24 }; 
        let direction = { x: -1, y: 0 }; 
        let queuedDirection = { x: 0, y: 0 }; 
        const moveSpeed = 4; 
        let lastTimestamp = 0; 
        let score = 0; 

        const map = [
            'WWWWWWWWWWWWWWWWWWWWWWWWWWWW',
            'W............WW............W',
            'W.WWWW.WWWWW.WW.WWWWW.WWWW.W',
            'W*WWWW.WWWWW.WW.WWWWW.WWWW*W',
            'W.WWWW.WWWWW.WW.WWWWW.WWWW.W',
            'W..........................W',
            'W.WWWW.WW.WWWWWWWW.WW.WWWW.W',
            'W.WWWW.WW.WWWWWWWW.WW.WWWW.W',
            'W......WW....WW....WW......W',
            'WWWWWW.WWWWW WW WWWWW.WWWWWW',
            '     W.WWWWW WW WWWWW.W     ',
            '     W.WW          WW.W     ',
            '     W.WW WWW--WWW WW.W     ',
            'WWWWWW.WW W      W WW.WWWWWW',
            '      .   W      W   .      ',
            'WWWWWW.WW W      W WW.WWWWWW',
            '     W.WW WWWWWWWW WW.W     ',
            '     W.WW          WW.W     ',
            '     W.WW WWWWWWWW WW.W     ',
            'WWWWWW.WW WWWWWWWW WW.WWWWWW',
            'W............WW............W',
            'W.WWWW.WWWWW.WW.WWWWW.WWWW.W',
            'W*WWWW.WWWWW.WW.WWWWW.WWWW*W',
            'W...WW................WW...W',
            'WWW.WW.WW.WWWWWWWW.WW.WW.WWW',
            'WWW.WW.WW.WWWWWWWW.WW.WW.WWW',
            'W......WW....WW....WW......W',
            'W.WWWWWWWWWW.WW.WWWWWWWWWW.W',
            'W.WWWWWWWWWW.WW.WWWWWWWWWW.W',
            'W..........................W',
            'WWWWWWWWWWWWWWWWWWWWWWWWWWWW'
        ];

        function createWalls() {
            map.forEach((row, rowIndex) => {
                [...row].forEach((cell, colIndex) => {
                    if (cell === 'W') {
                        const wall = document.createElement('div');
                        wall.classList.add('wall');
                        wall.style.gridColumn = `${colIndex + 1}`;
                        wall.style.gridRow = `${rowIndex + 1}`;
                        gameArea.appendChild(wall);
                    }
                });
            });
        }

        function createDots() {
            map.forEach((row, rowIndex) => {
                [...row].forEach((cell, colIndex) => {
                    if (cell === '.') {
                        const dot = document.createElement('div');
                        dot.classList.add('dot');
                        dot.style.gridColumn = `${colIndex + 1}`;
                        dot.style.gridRow = `${rowIndex + 1}`;
                        gameArea.appendChild(dot);
                    }
                });
            });
        }

        function canMoveTo(x, y) {
            const col = Math.round(x);
            const row = Math.round(y);

            // Kontrollera om positionen är inom spelområdet
            if (col < 1 || col > 28 || row < 1 || row > 31) {
                return false;
            }

            // Kontrollera om positionen inte är en vägg
            return map[row - 1] && map[row - 1][col - 1] !== 'W';
        }

        function checkWinCondition() {
            const remainingDots = document.querySelectorAll('.dot');
            if (remainingDots.length === 0) {
                alert('Grattis! Du vann spelet!');
                return true;
            }
            return false;
        }

        function movePacman(timestamp) {
            if (!lastTimestamp) {
                lastTimestamp = timestamp;
            }

            const deltaTime = (timestamp - lastTimestamp) / 1000;
            const distance = moveSpeed * deltaTime;

            if (queuedDirection.x !== 0 || queuedDirection.y !== 0) {
                const nextQueuedX = pacmanPosition.x + queuedDirection.x * distance;
                const nextQueuedY = pacmanPosition.y + queuedDirection.y * distance;

                if (canMoveTo(Math.round(pacmanPosition.x) + queuedDirection.x, Math.round(pacmanPosition.y) + queuedDirection.y)) {
                    direction = queuedDirection;
                    queuedDirection = { x: 0, y: 0 };
                }
            }

            const nextX = pacmanPosition.x + direction.x * distance;
            const nextY = pacmanPosition.y + direction.y * distance;

            if (canMoveTo(nextX, nextY)) {
                pacmanPosition.x = nextX;
                pacmanPosition.y = nextY;

                if (pacmanPosition.x < 1) {
                    pacmanPosition.x = 28;
                } else if (pacmanPosition.x > 28) {
                    pacmanPosition.x = 1;
                }

                pacmanPosition.x = Math.max(1, Math.min(28, pacmanPosition.x));
                pacmanPosition.y = Math.max(1, Math.min(31, pacmanPosition.y));

                pacman.style.gridColumn = Math.round(pacmanPosition.x);
                pacman.style.gridRow = Math.round(pacmanPosition.y);
                pacman.style.transform = `translate(${(pacmanPosition.x - Math.round(pacmanPosition.x)) * 100 / 50}%, ${(pacmanPosition.y - Math.round(pacmanPosition.y)) * 100 / 28}%)`;

                const dots = document.querySelectorAll('.dot');
                dots.forEach(dot => {
                    const dotCol = parseInt(dot.style.gridColumn);
                    const dotRow = parseInt(dot.style.gridRow);
                    if (dotCol === Math.round(pacmanPosition.x) && dotRow === Math.round(pacmanPosition.y)) {
                        dot.remove();
                        score += 10;
                        scoreElement.textContent = score; 
                        scoreElement.textContent = score; 
                    }
                });

                if (checkWinCondition()) {
                    return;
                }
            } else {
                direction = { x: 0, y: 0 };
            }

            lastTimestamp = timestamp;
            requestAnimationFrame(movePacman);
        }

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    queuedDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    queuedDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    queuedDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    queuedDirection = { x: 1, y: 0 };
                    break;
            }
        });

        createDots();
        createWalls();
        requestAnimationFrame(movePacman);
    </script>
    <script>
    const ghost = document.createElement('div');
    ghost.id = 'ghost';
    gameArea.appendChild(ghost);

    const ghost2 = document.createElement('div');
    ghost2.id = 'ghost2';
    ghost2.style.backgroundColor = 'pink'; // Unik färg för spöke 2
    ghost2.style.gridColumn = '13'; // Startkolumn
    ghost2.style.gridRow = '15'; // Startrad
    gameArea.appendChild(ghost2);

    const ghost3 = document.createElement('div');
    ghost3.id = 'ghost3';
    ghost3.style.backgroundColor = 'cyan'; // Unik färg för spöke 3
    ghost3.style.gridColumn = '15'; // Startkolumn
    ghost3.style.gridRow = '15'; // Startrad
    gameArea.appendChild(ghost3);

    const ghost4 = document.createElement('div');
    ghost4.id = 'ghost4';
    ghost4.style.backgroundColor = 'orange'; // Unik färg för spöke 4
    ghost4.style.gridColumn = '16'; // Startkolumn
    ghost4.style.gridRow = '15'; // Startrad
    gameArea.appendChild(ghost4);

    let ghostPosition = { x: 14, y: 15 }; // Startposition för spöket
    const ghostSpeed = 2; // Hastighet för spöket
    let lastGhostTimestamp = 0; // Separat tidsstämpel för spöket
    let isChasing = false; // Om spöket jagar Pacman
    const chaseDelay = 5000;

    function findShortestPath(start, target) {
        const queue = [[start]];
        const visited = new Set();
        visited.add(`${start.x},${start.y}`);

        while (queue.length > 0) {
            const path = queue.shift();
            const { x, y } = path[path.length - 1];

            if (x === target.x && y === target.y) {
                return path;
            }

            const directions = [
                { x: x + 1, y: y },
                { x: x - 1, y: y },
                { x: x, y: y + 1 },
                { x: x, y: y - 1 }

            ];

            for (const dir of directions) {
                if (
                    canMoveTo(dir.x, dir.y) &&
                    !visited.has(`${dir.x},${dir.y}`)
                ) {
                    visited.add(`${dir.x},${dir.y}`);
                    queue.push([...path, dir]);
                }
            }
        }

        return null;
    }

    function moveGhost(ghost, ghostPosition, timestamp, lastGhostTimestamp) {
        if (!lastGhostTimestamp) {
            lastGhostTimestamp = timestamp;
        }

        const deltaTime = (timestamp - lastGhostTimestamp) / 1000;
        const distance = ghostSpeed * deltaTime;

        let direction = { x: 0, y: 0 };

        if (isChasing) {
            const path = findShortestPath(
                { x: Math.round(ghostPosition.x), y: Math.round(ghostPosition.y) },
                { x: Math.round(pacmanPosition.x), y: Math.round(pacmanPosition.y) }
            );

            if (path && path.length > 1) {
                const nextStep = path[1];
                direction.x = nextStep.x - Math.round(ghostPosition.x);
                direction.y = nextStep.y - Math.round(ghostPosition.y);
            }
        } else {
 
            const possibleDirections = [
                
            ];

            const validDirections = possibleDirections.filter(dir => {
                const nextX = Math.round(ghostPosition.x) + dir.x;
                const nextY = Math.round(ghostPosition.y) + dir.y;
                return canMoveTo(nextX, nextY);
            });

            if (validDirections.length > 0) {
                direction = validDirections[Math.floor(Math.random() * validDirections.length)];
            }
        }

        ghostPosition.x += direction.x * distance;
        ghostPosition.y += direction.y * distance;

        ghost.style.gridColumn = Math.round(ghostPosition.x);
        ghost.style.gridRow = Math.round(ghostPosition.y);

        // Kontrollera om spöket fångar Pacman
        if (
            Math.round(ghostPosition.x) === Math.round(pacmanPosition.x) &&
            Math.round(ghostPosition.y) === Math.round(pacmanPosition.y)
        ) {
            alert('Game Over! Spöket fångade Pacman!');
            return; // Stoppa spelet
        }

        lastGhostTimestamp = timestamp;
        requestAnimationFrame((newTimestamp) => moveGhost(ghost, ghostPosition, newTimestamp, lastGhostTimestamp));
    }

    // Växla till jaktläge efter en viss tid
    setTimeout(() => {
        isChasing = true;
    }, chaseDelay);

    // Starta spökets rörelse
    requestAnimationFrame((timestamp) => moveGhost(ghost, ghostPosition, timestamp, 0));

    // Spöke 2: Följer en specifik runda
    function moveGhostInLoop(ghost, path, ghostPosition, timestamp, lastGhostTimestamp, speed) {
        if (!lastGhostTimestamp) {
            lastGhostTimestamp = timestamp;
        }

        const deltaTime = (timestamp - lastGhostTimestamp) / 1000;
        const distance = speed * deltaTime;

        // Hämta nästa position i rundan
        const nextStep = path[0]; // Ta nästa steg i rundan
        const dx = nextStep.x - ghostPosition.x;
        const dy = nextStep.y - ghostPosition.y;

        // Flytta spöket mot nästa steg
        const stepDistance = Math.sqrt(dx * dx + dy * dy);
        if (stepDistance <= distance) {
            // Om spöket når nästa steg, uppdatera positionen och gå till nästa steg
            ghostPosition.x = nextStep.x;
            ghostPosition.y = nextStep.y;
            path.push(path.shift()); // Flytta det aktuella steget till slutet av listan
        } else {
            // Annars, flytta spöket proportionellt mot nästa steg
            ghostPosition.x += (dx / stepDistance) * distance;
            ghostPosition.y += (dy / stepDistance) * distance;
        }

        ghost.style.gridColumn = Math.round(ghostPosition.x);
        ghost.style.gridRow = Math.round(ghostPosition.y);

        lastGhostTimestamp = timestamp;
        requestAnimationFrame((newTimestamp) =>
            moveGhostInLoop(ghost, path, ghostPosition, newTimestamp, lastGhostTimestamp, speed)
        );
    }

    // Spöke 3: Försöker ta Pacman framifrån
    function moveGhostPredictive(ghost, ghostPosition, timestamp, lastGhostTimestamp, speed) {
        if (!lastGhostTimestamp) {
            lastGhostTimestamp = timestamp;
        }

        const deltaTime = (timestamp - lastGhostTimestamp) / 1000;
        const distance = speed * deltaTime;

        const predictedPosition = {
            x: pacmanPosition.x + direction.x * 2,
            y: pacmanPosition.y + direction.y * 2,
        };

        const path = findShortestPath(
            { x: Math.round(ghostPosition.x), y: Math.round(ghostPosition.y) },
            { x: Math.round(predictedPosition.x), y: Math.round(predictedPosition.y) }
        );

        let direction = { x: 0, y: 0 };
        if (path && path.length > 1) {
            const nextStep = path[1];
            direction.x = nextStep.x - Math.round(ghostPosition.x);
            direction.y = nextStep.y - Math.round(ghostPosition.y);
        }

        ghostPosition.x += direction.x * distance;
        ghostPosition.y += direction.y * distance;

        ghost.style.gridColumn = Math.round(ghostPosition.x);
        ghost.style.gridRow = Math.round(ghostPosition.y);

        lastGhostTimestamp = timestamp;
        requestAnimationFrame((newTimestamp) =>
            moveGhostPredictive(ghost, ghostPosition, newTimestamp, lastGhostTimestamp, speed)
        );
    }

    // Starta rörelse för varje spöke med olika logik
    requestAnimationFrame((timestamp) => moveGhost(ghost, ghostPosition, timestamp, 0)); // Spöke 1

    setTimeout(() => {
        const ghostPosition3 = { x: 15, y: 15 };
        requestAnimationFrame((timestamp) =>
            moveGhostPredictive(ghost3, ghostPosition3, timestamp, 0, 4) // Snabbare än Pacman
        );
    }, 30000);

    setTimeout(() => {
        const ghostPosition4 = { x: 16, y: 15 };
        requestAnimationFrame((timestamp) =>
            moveGhost(ghost4, ghostPosition4, timestamp, 4) // Slumpmässig patrullering
        );
    }, 45000);
</script>
</body>
</html>