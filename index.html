<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman</title>
    <link rel="stylesheet" href="style.css"> <!-- Lägg till denna rad -->
</head>
<body>
     <script src="pinkghost.js"></script>
    <div id="scoreContainer">
        <p>Poäng: <span id="score">0</span></p>
    </div>
    <div id="gameContainer">
        <div id="gameArea">
            <div id="pacman"></div>
        </div>
    </div>
    <script>
        const pacman = document.getElementById('pacman');
        const gameArea = document.getElementById('gameArea');
        const scoreElement = document.getElementById('score');
        let pacmanPosition = { x: 15, y: 24 }; 
        let direction = { x: -1, y: 0 }; 
        let queuedDirection = { x: 0, y: 0 }; 
        const moveSpeed = 4; 
        let lastTimestamp = 0; 
        let score = 0; 

        const map = [
            'WWWWWWWWWWWWWWWWWWWWWWWWWWWW',
            'W............WW............W',
            'W.WWWW.WWWWW.WW.WWWWW.WWWW.W',
            'W*WWWW.WWWWW.WW.WWWWW.WWWW*W',
            'W.WWWW.WWWWW.WW.WWWWW.WWWW.W',
            'W..........................W',
            'W.WWWW.WW.WWWWWWWW.WW.WWWW.W',
            'W.WWWW.WW.WWWWWWWW.WW.WWWW.W',
            'W......WW....WW....WW......W',
            'WWWWWW.WWWWW WW WWWWW.WWWWWW',
            '     W.WWWWW WW WWWWW.W     ',
            '     W.WW          WW.W     ',
            '     W.WW WWW--WWW WW.W     ',
            'WWWWWW.WW W      W WW.WWWWWW',
            '      .   W      W   .      ',
            'WWWWWW.WW W      W WW.WWWWWW',
            '     W.WW WWWWWWWW WW.W     ',
            '     W.WW          WW.W     ',
            '     W.WW WWWWWWWW WW.W     ',
            'WWWWWW.WW WWWWWWWW WW.WWWWWW',
            'W............WW............W',
            'W.WWWW.WWWWW.WW.WWWWW.WWWW.W',
            'W*WWWW.WWWWW.WW.WWWWW.WWWW*W',
            'W...WW................WW...W',
            'WWW.WW.WW.WWWWWWWW.WW.WW.WWW',
            'WWW.WW.WW.WWWWWWWW.WW.WW.WWW',
            'W......WW....WW....WW......W',
            'W.WWWWWWWWWW.WW.WWWWWWWWWW.W',
            'W.WWWWWWWWWW.WW.WWWWWWWWWW.W',
            'W..........................W',
            'WWWWWWWWWWWWWWWWWWWWWWWWWWWW'
        ];

        function createWalls() {
            map.forEach((row, rowIndex) => {
                [...row].forEach((cell, colIndex) => {
                    if (cell === 'W') {
                        const wall = document.createElement('div');
                        wall.classList.add('wall');
                        wall.style.gridColumn = `${colIndex + 1}`;
                        wall.style.gridRow = `${rowIndex + 1}`;
                        gameArea.appendChild(wall);
                    }
                });
            });
        }

        function createDots() {
            map.forEach((row, rowIndex) => {
                [...row].forEach((cell, colIndex) => {
                    if (cell === '.') {
                        const dot = document.createElement('div');
                        dot.classList.add('dot');
                        dot.style.gridColumn = `${colIndex + 1}`;
                        dot.style.gridRow = `${rowIndex + 1}`;
                        gameArea.appendChild(dot);
                    }
                });
            });
        }

        function canMoveTo(x, y) {
            const col = Math.round(x);
            const row = Math.round(y);

            // Kontrollera om positionen är inom spelområdet
            if (col < 1 || col > 28 || row < 1 || row > 31) {
                return false;
            }

            // Kontrollera om positionen inte är en vägg
            return map[row - 1] && map[row - 1][col - 1] !== 'W';
        }

        function checkWinCondition() {
            const remainingDots = document.querySelectorAll('.dot');
            if (remainingDots.length === 0) {
                alert('Grattis! Du vann spelet!');
                return true;
            }
            return false;
        }

        function movePacman(timestamp) {
            if (!lastTimestamp) {
                lastTimestamp = timestamp;
            }

            const deltaTime = (timestamp - lastTimestamp) / 1000;
            const distance = moveSpeed * deltaTime;

            if (queuedDirection.x !== 0 || queuedDirection.y !== 0) {
                const nextQueuedX = pacmanPosition.x + queuedDirection.x * distance;
                const nextQueuedY = pacmanPosition.y + queuedDirection.y * distance;

                if (canMoveTo(Math.round(pacmanPosition.x) + queuedDirection.x, Math.round(pacmanPosition.y) + queuedDirection.y)) {
                    direction = queuedDirection;
                    queuedDirection = { x: 0, y: 0 };
                }
            }

            const nextX = pacmanPosition.x + direction.x * distance;
            const nextY = pacmanPosition.y + direction.y * distance;

            if (canMoveTo(nextX, nextY)) {
                pacmanPosition.x = nextX;
                pacmanPosition.y = nextY;

                if (pacmanPosition.x < 1) {
                    pacmanPosition.x = 28;
                } else if (pacmanPosition.x > 28) {
                    pacmanPosition.x = 1;
                }

                pacmanPosition.x = Math.max(1, Math.min(28, pacmanPosition.x));
                pacmanPosition.y = Math.max(1, Math.min(31, pacmanPosition.y));

                pacman.style.gridColumn = Math.round(pacmanPosition.x);
                pacman.style.gridRow = Math.round(pacmanPosition.y);
                pacman.style.transform = `translate(${(pacmanPosition.x - Math.round(pacmanPosition.x)) * 100 / 50}%, ${(pacmanPosition.y - Math.round(pacmanPosition.y)) * 100 / 28}%)`;

                const dots = document.querySelectorAll('.dot');
                dots.forEach(dot => {
                    const dotCol = parseInt(dot.style.gridColumn);
                    const dotRow = parseInt(dot.style.gridRow);
                    if (dotCol === Math.round(pacmanPosition.x) && dotRow === Math.round(pacmanPosition.y)) {
                        dot.remove();
                        score += 10;
                        scoreElement.textContent = score; 
                        scoreElement.textContent = score; 
                    }
                });

                if (checkWinCondition()) {
                    return;
                }

                // Kontrollera kollision med alla spöken
                const ghostPositions = [
                    ghostPosition, // röd
                    ghostPosition2, // rosa
                    ghostPosition3, // blå
                    ghostPosition4  // orange
                ];
                for (const pos of ghostPositions) {
                    if (pos && checkGhostCollision(pos)) {
                        alert('Game Over! Spöket fångade Pacman!');
                        return;
                    }
                }
            } else {
                direction = { x: 0, y: 0 };
            }

            lastTimestamp = timestamp;
            requestAnimationFrame(movePacman);
        }

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    queuedDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    queuedDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    queuedDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    queuedDirection = { x: 1, y: 0 };
                    break;
            }
        });

        createDots();
        createWalls();
        requestAnimationFrame(movePacman);

    </script>
    
    <script>
    const ghost = document.createElement('div');
    ghost.id = 'ghost';
    gameArea.appendChild(ghost);

    const ghost2 = document.createElement('div');
    ghost2.id = 'ghost2';
    ghost2.style.backgroundColor = 'pink'; 
    ghost2.style.gridColumn = '13';
    ghost2.style.gridRow = '15';
    gameArea.appendChild(ghost2);

    const ghost3 = document.createElement('div');
    ghost3.id = 'ghost3';
    ghost3.style.backgroundColor = 'cyan'; 
    ghost3.style.gridColumn = '15'; 
    ghost3.style.gridRow = '15';
    gameArea.appendChild(ghost3);

    const ghost4 = document.createElement('div');
    ghost4.id = 'ghost4';
    ghost4.style.backgroundColor = 'orange'
    ghost4.style.gridColumn = '16';
    ghost4.style.gridRow = '15'; 
    gameArea.appendChild(ghost4);

    let ghostPosition = { x: 14, y: 15 }; 
    let ghostPosition2 = { x: 13, y: 15 };
    let ghostPosition3 = { x: 15, y: 15 };
    let ghostPosition4 = { x: 16, y: 15 };
    const ghostSpeed = 4; 
    let lastGhostTimestamp = 0; 
    let isChasing = false; 
    const chaseDelay = 5000;

    function findShortestPath(start, target) {
        const queue = [[start]];
        const visited = new Set();
        visited.add(`${start.x},${start.y}`);

        while (queue.length > 0) {
            const path = queue.shift();
            const { x, y } = path[path.length - 1];

            if (x === target.x && y === target.y) {
                return path;
            }

            const directions = [
                { x: x + 1, y: y },
                { x: x - 1, y: y },
                { x: x, y: y + 1 },
                { x: x, y: y - 1 }
            ];

            for (const dir of directions) {
                if (
                    canMoveTo(dir.x, dir.y) &&
                    !visited.has(`${dir.x},${dir.y}`)
                ) {
                    visited.add(`${dir.x},${dir.y}`);
                    queue.push([...path, dir]);
                }
            }
        }

        return null;
    }

    // Kontrollera om Pacman kolliderar med ett spöke
    function checkGhostCollision(ghostPosition) {
        return (
            Math.round(ghostPosition.x) === Math.round(pacmanPosition.x) &&
            Math.round(ghostPosition.y) === Math.round(pacmanPosition.y)
        );
    }

    // Modifiera moveGhost
    function moveGhost(ghost, ghostPosition, timestamp, lastGhostTimestamp) {
        if (!lastGhostTimestamp) {
            lastGhostTimestamp = timestamp;
        }

        const deltaTime = (timestamp - lastGhostTimestamp) / 1000;
        const distance = ghostSpeed * deltaTime;

        let direction = { x: 0, y: 0 };

        if (isChasing) {
            const path = findShortestPath(
                { x: Math.round(ghostPosition.x), y: Math.round(ghostPosition.y) },
                { x: Math.round(pacmanPosition.x), y: Math.round(pacmanPosition.y) }
            );

            if (path && path.length > 1) {
                const nextStep = path[1];
                direction.x = nextStep.x - Math.round(ghostPosition.x);
                direction.y = nextStep.y - Math.round(ghostPosition.y);
            }
        } else {
            const possibleDirections = [];
            const validDirections = possibleDirections.filter(dir => {
                const nextX = Math.round(ghostPosition.x) + dir.x;
                const nextY = Math.round(ghostPosition.y) + dir.y;
                return canMoveTo(nextX, nextY);
            });

            if (validDirections.length > 0) {
                direction = validDirections[Math.floor(Math.random() * validDirections.length)];
            }
        }

        ghostPosition.x += direction.x * distance;
        ghostPosition.y += direction.y * distance;

        ghost.style.gridColumn = Math.round(ghostPosition.x);
        ghost.style.gridRow = Math.round(ghostPosition.y);

        // Kontrollera kollision med Pacman
        if (checkGhostCollision(ghostPosition)) {
            alert('Game Over! Spöket fångade Pacman!');
            return;
        }

        lastGhostTimestamp = timestamp;
        requestAnimationFrame((newTimestamp) => moveGhost(ghost, ghostPosition, newTimestamp, lastGhostTimestamp));
    }

    // Modifiera moveGhostInLoop
    function moveGhostInLoop(ghost, path, ghostPosition, timestamp, lastGhostTimestamp, speed) {
        if (!lastGhostTimestamp) {
            lastGhostTimestamp = timestamp;
        }

        const deltaTime = (timestamp - lastGhostTimestamp) / 1000;
        const distance = speed * deltaTime;

        const nextStep = path[0];
        const dx = nextStep.x - ghostPosition.x;
        const dy = nextStep.y - ghostPosition.y;

        const stepDistance = Math.sqrt(dx * dx + dy * dy);
        if (stepDistance <= distance) {
            ghostPosition.x = nextStep.x;
            ghostPosition.y = nextStep.y;
            path.push(path.shift());
        } else {
            ghostPosition.x += (dx / stepDistance) * distance;
            ghostPosition.y += (dy / stepDistance) * distance;
        }

        ghost.style.gridColumn = Math.round(ghostPosition.x);
        ghost.style.gridRow = Math.round(ghostPosition.y);

        // Kontrollera kollision med Pacman
        if (checkGhostCollision(ghostPosition)) {
            alert('Game Over! Spöket fångade Pacman!');
            return;
        }

        lastGhostTimestamp = timestamp;
        requestAnimationFrame((newTimestamp) =>
            moveGhostInLoop(ghost, path, ghostPosition, newTimestamp, lastGhostTimestamp, speed)
        );
    }

    // Modifiera moveGhostPredictive
    function moveGhostPredictive(ghost, ghostPosition, timestamp, lastGhostTimestamp, speed) {
        if (!lastGhostTimestamp) {
            lastGhostTimestamp = timestamp;
        }

        const deltaTime = (timestamp - lastGhostTimestamp) / 1000;
        const distance = speed * deltaTime;

        const predictedPosition = {
            x: pacmanPosition.x + direction.x * 2,
            y: pacmanPosition.y + direction.y * 2,
        };

        const path = findShortestPath(
            { x: Math.round(ghostPosition.x), y: Math.round(ghostPosition.y) },
            { x: Math.round(predictedPosition.x), y: Math.round(predictedPosition.y) }
        );

        let dir = { x: 0, y: 0 };
        if (path && path.length > 1) {
            const nextStep = path[1];
            dir.x = nextStep.x - Math.round(ghostPosition.x);
            dir.y = nextStep.y - Math.round(ghostPosition.y);
        }

        ghostPosition.x += dir.x * distance;
        ghostPosition.y += dir.y * distance;

        ghost.style.gridColumn = Math.round(ghostPosition.x);
        ghost.style.gridRow = Math.round(ghostPosition.y);

        // Kontrollera kollision med Pacman
        if (checkGhostCollision(ghostPosition)) {
            alert('Game Over! Spöket fångade Pacman!');
            return;
        }

        lastGhostTimestamp = timestamp;
        requestAnimationFrame((newTimestamp) =>
            moveGhostPredictive(ghost, ghostPosition, newTimestamp, lastGhostTimestamp, speed)
        );
    }

    setTimeout(() => {
        isChasing = true;
    }, chaseDelay);

    requestAnimationFrame((timestamp) => moveGhost(ghost, ghostPosition, timestamp, 0));

    setTimeout(() => {
        requestAnimationFrame((timestamp) =>
            moveGhostPredictive(ghost3, ghostPosition3, timestamp, 0, 4) // Snabbare än Pacman
        );
    }, 30000);

    setTimeout(() => {
        requestAnimationFrame((timestamp) =>
            moveGhost(ghost4, ghostPosition4, timestamp, 0) // Slumpmässig patrullering
        );
    }, 45000);
</script>
</body>
</html>